import logging
import os
import json
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ó–∞–≥—Ä—É–∑–∫–∞ –≤–æ–ø—Ä–æ—Å–æ–≤
def load_questions():
    try:
        with open('questions.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        # –ü—Ä–∏–º–µ—Ä –≤–æ–ø—Ä–æ—Å–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        default_questions = {
            "1": {
                "question": "–°—Ç–æ–ª–∏—Ü–∞ –§—Ä–∞–Ω—Ü–∏–∏?",
                "options": ["–õ–æ–Ω–¥–æ–Ω", "–ë–µ—Ä–ª–∏–Ω", "–ü–∞—Ä–∏–∂", "–ú–∞–¥—Ä–∏–¥"],
                "correct_answer": 2
            },
            "2": {
                "question": "2 + 2 * 2 = ?",
                "options": ["6", "8", "4", "10"],
                "correct_answer": 0
            },
            "3": {
                "question": "–°–∞–º–∞—è –±–æ–ª—å—à–∞—è –ø–ª–∞–Ω–µ—Ç–∞ –°–æ–ª–Ω–µ—á–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã?",
                "options": ["–ó–µ–º–ª—è", "–ú–∞—Ä—Å", "–Æ–ø–∏—Ç–µ—Ä", "–°–∞—Ç—É—Ä–Ω"],
                "correct_answer": 2
            }
        }
        with open('questions.json', 'w', encoding='utf-8') as f:
            json.dump(default_questions, f, ensure_ascii=False, indent=2)
        return default_questions

questions = load_questions()
user_progress = {}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_progress[user_id] = {"current_question": 1, "score": 0}
    
    keyboard = [
        [InlineKeyboardButton("–ù–∞—á–∞—Ç—å —Ç–µ—Å—Ç", callback_data="start_test")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —ç–∫–∑–∞–º–µ–Ω–∞—Ü–∏–æ–Ω–Ω—ã–π –±–æ—Ç! üéì\n\n"
        "–ù–∞–∂–º–∏—Ç–µ '–ù–∞—á–∞—Ç—å —Ç–µ—Å—Ç' —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å.",
        reply_markup=reply_markup
    )

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    data = query.data
    
    if user_id not in user_progress:
        user_progress[user_id] = {"current_question": 1, "score": 0}
    
    if data == "start_test":
        await show_question(update, context, user_id, "1")
    elif data.startswith("answer_"):
        parts = data.split("_")
        question_id = parts[1]
        answer_index = int(parts[2])
        
        correct_answer = questions[question_id]["correct_answer"]
        
        if answer_index == correct_answer:
            user_progress[user_id]["score"] += 1
            await show_answer_feedback(update, context, question_id, answer_index, True)
        else:
            await show_answer_feedback(update, context, question_id, answer_index, False)
        
        # –ü—Ä–æ—Å—Ç–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –≤–º–µ—Å—Ç–æ job_queue
        import asyncio
        await asyncio.sleep(2)
        await show_next_question(context, user_id, question_id)
        
    elif data == "restart":
        user_progress[user_id] = {"current_question": 1, "score": 0}
        await show_question(update, context, user_id, "1")

async def show_answer_feedback(update: Update, context: ContextTypes.DEFAULT_TYPE, 
                             question_id: str, answer_index: int, is_correct: bool):
    query = update.callback_query
    question = questions[str(question_id)]
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π
    keyboard = []
    for i, option in enumerate(question["options"]):
        if i == answer_index:
            if is_correct:
                button_text = f"‚úÖ {option}"
            else:
                button_text = f"‚ùå {option}"
        elif i == question["correct_answer"] and not is_correct:
            button_text = f"‚úÖ {option}"
        else:
            button_text = option
            
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"dummy_{question_id}_{i}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if is_correct:
        message = "‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ! –ú–æ–ª–æ–¥–µ—Ü!"
    else:
        message = f"‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ! –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: {question['options'][question['correct_answer']]}"
    
    await query.edit_message_text(
        text=f"{question['question']}\n\n{message}",
        reply_markup=reply_markup
    )

async def show_next_question(context, user_id, current_question_id):
    next_question_id = str(int(current_question_id) + 1)
    
    if next_question_id in questions:
        user_progress[user_id]["current_question"] = int(next_question_id)
        await show_question(None, context, user_id, next_question_id)
    else:
        # –¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω
        score = user_progress[user_id]["score"]
        total = len(questions)
        
        keyboard = [
            [InlineKeyboardButton("–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ", callback_data="restart")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await context.bot.send_message(
            chat_id=user_id,
            text=f"üéâ –¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω!\n–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {score}/{total}\n\n"
                 f"–ü—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤: {round(score/total*100)}%",
            reply_markup=reply_markup
        )

async def show_question(update: Update, context: ContextTypes.DEFAULT_TYPE, 
                       user_id: int, question_id: str):
    question = questions[question_id]
    
    keyboard = []
    for i, option in enumerate(question["options"]):
        keyboard.append([
            InlineKeyboardButton(
                f"{['A', 'B', 'C', 'D'][i]}. {option}", 
                callback_data=f"answer_{question_id}_{i}"
            )
        ])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    text = f"–í–æ–ø—Ä–æ—Å {question_id}/{len(questions)}\n\n{question['question']}"
    
    if update and update.callback_query:
        await update.callback_query.edit_message_text(text, reply_markup=reply_markup)
    else:
        await context.bot.send_message(user_id, text, reply_markup=reply_markup)

def main():
    # –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
    TOKEN = os.getenv('TELEGRAM_TOKEN')
    if not TOKEN:
        logger.error("–¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω! –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è TELEGRAM_TOKEN")
        return
    
    application = Application.builder().token(TOKEN).build()
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(handle_callback))
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
    logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    application.run_polling()

if __name__ == "__main__":
    main()
